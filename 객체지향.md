- getter, setter 쓰는이유

```
class Human{
	int age;
	String name;
	
	private void setAge(int age){
		if (age < 0){
			return raise errer;
		}
		this.age = age;
		return true;
	}
}
```

캡슐화를 해야하는 이유.

- 요구사항의 변화가 발생했을 때 절자치향 보다 프로그램을 더 쉽게 변경할 수 있기 때문이다.
- 자세한사항은 뒤에 캡슐화에서 보자.



객체지향

- 기능을 제공한다.
- 절차지향은 데이터 중심, 객체지향은 기능 중심
- 객체 = 데이터 + 프로시져(오퍼레이션, 메소드, 함수)



인터페이스

- 개념적 인터페이스

  : 객체가 제공하는 모든 오퍼레이션(기능)의 집합을 객체의 인터페이스라고 부른다. 객체를 사용하기 위한 일종의 명세 혹은 규칙이라고 생각하자.  한객체가 갖는 책임을 정의한 것

- 각각 언어에서 지원하는 인터페이스 -> 자바에서는 interface => implement로 인터페이스의 목적을 달성하게 하는 기능이 있다. 인터페이스는 오퍼레이션의 정의, implement에서 구현



메시지

- 오퍼레이션의 실행을 요청하는 것을 메시지라고 한다.
- 자바의 경우, 메서드를 호출하는 것이 메시지를 보내는 과정에 해당된다.



객체지향의 규칙

- 객체가 갖는 책임의 크기가 작을수록 좋다 === 객체가 제공하는 기능의 개수가 적다 => 단일 책임원칙 : single responsibility pinciple (SRP)
-  => solid  설계규칙에서 더 자세히 알아보자

의존

- 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할때 의존이라고 표현한다.
- 객체를 생성하거나 메서드를 호출하는 것뿐만 아니라 파라미터로 전달받은 경우에도 의존이다/

- 순환의존이 발생하지 않도록 하는 원칙중의 하나가 의존 역전 원칙이다 DIP(dependency inverseion principle) => solid의 하나

UML  다이어그램

- unified modeling language 다이어그램의 약자. 
- 객체 관리 그룹으로 관리하기 위한 다이어그램



의존의 양면성 ( 이해가 잘 가지 않는 부분)

- 클래스간의 의존성이 존재하면, 하나의 클래스의 변경은 의존성 관계를 가진 클래스의 변경을 야기한다. 그럼 어떻게 관리해?? 어렵네 즉 약간 양방향 링크드 리스트의 연결을 고려하는거랑 비슷?
  - 내가 변경되면 나에게 의존하고 있는 코드에 영향을 준다
  - 나의 요구가 변경되면 내가 의존하고 있는 타입에 영향을 준다.

캡슐화와 의존의 양면성은 서로 충돌하는데 이걸 어떻게 설명해야하지?



캡슐화( 3요소 중 하나)

- 객체지향의 장점: 한 곳의 구현 변경이 다른 곳에 변경을 가하지 않도록 하는데 있다.
- 캡슐화란: 객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것 즉, 내부 구현이 변경되더라도 그 기능을 사용하는 코드는 영향을 받지 않는다.

- 캡슐화를 위한 두개의 규칙

  - Tell Don't Ask : 데이터를 묻지 말고, 기능을 호출해라

  ```java
  // 절차지향
  if (member.getExpiryDate()!=null && member.getExpiryDate().getDate() < System.currentTimeMillis()){
      // 처리
  }
  
  // 객체지향
  if (member.isExpired()){
      // 처리
  }
  ```

  

  - law of memeter(데미테르의 법칙)

    - 위의 규칙을 따를 수 있도록 만들어 주는 또 다른 규칙
      1. 메서드에서 생성한 객체의 메서드만 호출
      2. 파라미터로 받은 객체의 메서드만 호출
      3. 필드로 참조하는 객체의 메서드만 호출

    ```
    // ex
    if (member.getDate().getTime()< ...){ // 데미테르 법칙 위반
    }
    
    // 그럼 어떻게해야함?
    
    class member {
    	private Datetime datetime;
    	
    	public getDate(){
    	return this.datetime;
    	}
    	public getTimeByDate() {
    	return this.getDate().getTime();
    	}
    }
    
    if (member.getTimeByDate() < ...){
    	// 데미테르 법칙 지킴
    }
    ```

    - 소트워크 앤솔로지에서...

    ```
    디미터의 법칙("친구하고만 대화하라")이 좋은 출발점이긴 하지만, 이런 식으로 생각하자. 자기 소유의 장난감, 자기가 만든 장난감, 그리고 누군가 자기에게 준 장난감하고만 놀 수 있다. 하지만 절대 장난감의 장난감과 놀면 안 된다.
    ```

    - 데미테르의 법칙 == 메소드 체이닝을 사용하지 마라 이뜻은 아니다.

    ```
    // 이렇게 써도 문제 없음
    IntStream.of(1, 15, 20, 3, 9)
        .filter(x -> x > 10)
        .distinct()
        .count();
    
    ```
    
    - 위 코드에서 `of`, `filter`, `distinct` 메서드는 모두 `IntStream`이라는 동일한 클래스의 인스턴스를 반환한다. 
- 즉, 이들은 `IntStream`의 인스턴스를 또다른 `IntStream`의 인스턴스로 변환한다.  따라서 이 코드는 디미터 법칙을 위반하지 않는다. 
    - 디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다. 
    - `IntStream`의 내부 구조가 외부로 노출됐는가? 그렇지 않다. 단지 `IntStream`을 다른 `IntStream`으로 변환할 뿐, 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.
    - 출처: https://johngrib.github.io/wiki/law-of-demeter/#%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%B2%B4%EC%9D%B8%EC%9D%98-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81
    

키워드

- is a / has
- 다형성 오버라이드와 인터페이스 임플리먼트와의 다른점